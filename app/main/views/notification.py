from flask import jsonify, current_app, request, abort
from app.main.validators import valid_sms_notification
from .. import main, get_token_from_headers
from ... import db, sms_wrapper
from sqlalchemy.exc import IntegrityError, DataError
from app.main.views import get_json_from_request
from app.models import Service, Job, Notification, Token, Usage
from datetime import datetime
from sqlalchemy import desc
from app.main.auth.token_auth import token_type_required


@main.route('/notifications', methods=['GET'])
@token_type_required('client', 'admin')
def fetch_notifications():
    incoming_token = get_token_from_headers(request.headers)
    service = Service.query.filter(Service.token == incoming_token).first_or_404()

    notifications = Notification.query.join(Job).filter(Job.service_id == service.id).all()

    return jsonify(
        notifications=[notification.serialize() for notification in notifications],
    )


@main.route('/job/<int:job_id>/notifications', methods=['GET'])
@token_type_required('client', 'admin')
def fetch_notifications_by_job(job_id):
    notifications = Notification.query.join(Job).filter(
        Job.id == job_id
    ).order_by(desc(Notification.created_at)).all()
    return jsonify(
        notifications=[notification.serialize() for notification in notifications]
    )


@main.route('/sms/notification', methods=['POST'])
@token_type_required('client', 'admin')
def create_sms_notification():
    if not current_app.config['SMS_ENABLED']:
        return jsonify(error="SMS is unavailable"), 503

    notification_request = get_json_from_request('notification')

    validation_result, validation_errors = valid_sms_notification(notification_request)

    if not validation_result:
        return jsonify(
            error="Invalid JSON",
            error_details=validation_errors
        ), 400

    incoming_token = get_token_from_headers(request.headers)

    if not incoming_token:
        return jsonify(error="No credentials supplied"), 400

    service = Service.query.join(Token).filter(Token.token == incoming_token).first()

    if not service:
        return jsonify(error="No service associated with these credentials"), 400

    if not service.active:
        return jsonify(error="Service is inactive"), 400

    if "jobId" in notification_request:
        job = Job.query.filter(Job.id == notification_request["jobId"]).first()
        if not job:
            return jsonify(error="No job associated with this job id"), 400
        elif job.service_id != service.id:
            abort(400, "Invalid job id for these credentials")
    else:
        job = Job(name="Autogenerated", created_at=datetime.utcnow(), service=service)

    if service.restricted:
        if not notification_request['to'] in [user.mobile_number for user in service.users]:
            abort(400, "Restricted service: cannot send notification to this number")

    usage = Usage.query.filter(Usage.day == datetime.utcnow().date(), Usage.service_id == service.id).first()
    if usage:
        usage.count += 1
    else:
        usage = Usage(
            day=datetime.utcnow().date(),
            count=1,
            service_id=service.id
        )

    if usage.count > service.limit:
        abort(429, "Exceeded sending limits for today")

    notification = Notification(
        to=notification_request['to'],
        message=notification_request['message'],
        status='created',
        method='sms',
        created_at=datetime.utcnow(),
        job=job
    )

    if 'description' in notification_request:
        job.name = notification_request['description']

    try:
        db.session.add(usage)
        db.session.add(notification)
        db.session.commit()
    except IntegrityError:
        db.session.rollback()
        abort(400, "Failed to create notification: DB error")

    return jsonify(notification=Notification.query.filter(Notification.id == notification.id).first().serialize()), 201
